"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addCommandLineArgsFooter = exports.addContent = void 0;
const write_markdown_constants_1 = require("../write-markdown.constants");
const line_ending_helper_1 = require("./line-ending.helper");
/**
 * Adds or replaces content between 2 markers within a text string
 * @param inputString
 * @param content
 * @param options
 * @returns
 */
function addContent(inputString, content, options) {
    const replaceBelow = options?.replaceBelow;
    const replaceAbove = options?.replaceAbove;
    content = Array.isArray(content) ? content : [content];
    const lineBreak = (0, line_ending_helper_1.findEscapeSequence)(inputString);
    const lines = (0, line_ending_helper_1.splitContent)(inputString);
    const replaceBelowLine = replaceBelow != null ? lines.filter((line) => line.indexOf(replaceBelow) === 0)[0] : undefined;
    const replaceBelowIndex = replaceBelowLine != null ? lines.indexOf(replaceBelowLine) : -1;
    const replaceAboveLine = replaceAbove != null ? lines.filter((line) => line.indexOf(replaceAbove) === 0)[0] : undefined;
    const replaceAboveIndex = replaceAboveLine != null ? lines.indexOf(replaceAboveLine) : -1;
    if (replaceAboveIndex > -1 && replaceBelowIndex > -1 && replaceAboveIndex < replaceBelowIndex) {
        throw new Error(`The replaceAbove marker '${options.replaceAbove}' was found before the replaceBelow marker '${options.replaceBelow}'. The replaceBelow marked must be before the replaceAbove.`);
    }
    const linesBefore = lines.slice(0, replaceBelowIndex + 1);
    const linesAfter = replaceAboveIndex >= 0 ? lines.slice(replaceAboveIndex) : [];
    const contentLines = content.reduce((lines, currentContent) => [...lines, ...(0, line_ending_helper_1.splitContent)(currentContent)], new Array());
    let allLines = [...linesBefore, ...contentLines, ...linesAfter];
    if (options.removeDoubleBlankLines) {
        allLines = allLines.filter((line, index, lines) => (0, line_ending_helper_1.filterDoubleBlankLines)(line, index, lines));
    }
    return allLines.join(lineBreak);
}
exports.addContent = addContent;
function addCommandLineArgsFooter(fileContent) {
    if (fileContent.indexOf(write_markdown_constants_1.footerReplaceBelowMarker) < 0) {
        fileContent = `${fileContent}  

${write_markdown_constants_1.footerReplaceBelowMarker}`;
    }
    const footerContent = `Markdown Generated by [ts-command-line-args](https://www.npmjs.com/package/ts-command-line-args)`;
    return addContent(fileContent, footerContent, {
        replaceBelow: write_markdown_constants_1.footerReplaceBelowMarker,
        removeDoubleBlankLines: false,
    });
}
exports.addCommandLineArgsFooter = addCommandLineArgsFooter;
